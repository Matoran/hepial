/*
    Cyril ISELI, Marco RODRIGUES
    
    Janvier 2017

    GRAMMAIRE HEPIAL
*/

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import TDS.*;
import ArbreAbstrait.*;



parser code {:
    private Lexer lexer = (Lexer)getScanner();
    private TDS tds = TDS.getInstance();
    private Type dernierType;
    private int ligne = 0;
    private Stack<ArbreAbstrait> pileArbres = new Stack<ArbreAbstrait>();
:}

//--------------------Terminaux----------------------------------------
//mot clef
terminal DEBUT_PRG, FIN_PRG, PROGRAMME, DEBUT_FONC, FIN_FONC, RETOURNE;
//type
terminal TypeEntier ENTIER;
terminal TypeBoolean BOOLEEN;
terminal int CONSTANTE_ENT;
terminal String IDENT, CONSTANTE_CHAINE;
terminal CONSTANTE, VRAI, FAUX;
//operateur
terminal PARENTHESE_OUVRANTE, PARENTHESE_FERMANTE, VIRGULE, EGAL, POINT_VIRGULE, CROCHET_OUVRANT, CROCHET_FERMANT, POINT_POINT, PLUS, MOINS, FOIS, DIVISER, EGAL_EGAL, DIFFERENT, PLUS_PETIT, PLUS_PETIT_OU_EGAL, PLUS_GRAND, PLUS_GRAND_OU_EGAL, ET, OU, TILDE, NON;
//IO
terminal LIRE, ECRIRE;
//condition
terminal SI, ALORS, SINON, FIN_SI;
//boucle
terminal TANT_QUE, FAIRE, FIN_TANT_QUE, POUR, ALLANT_DE, A, FIN_POUR;

//--------------------Non Terminaux------------------------------------
non terminal axiome, programme, entete, decla, decla_var, decla_const, decla_fonc, decla_fonc_debut, decla_fonc_fin, type, type_base, tableau, dim, param, corps, instr, lire, ecrire, affectation, retour, condition, tant_que, pour, expr, acces, index, operande, ope_un, appel_fct, par_eff, instrTemp, indexTemp, declas;
non terminal ArrayList<String> lident;
non terminal String ope_bin;

//--------------------Precedences--------------------------------------
precedence left PLUS, MOINS, FOIS, DIVISER, EGAL_EGAL, DIFFERENT, PLUS_PETIT, PLUS_PETIT_OU_EGAL, PLUS_GRAND, PLUS_GRAND_OU_EGAL, ET, OU, POINT_POINT;
precedence right TILDE, NON;


//-------------------Regles de grammaire--------------------------------
axiome ::= programme {: System.out.println(tds); :};
programme ::= entete declas DEBUT_PRG corps FIN_PRG
{:
    tds.sortieBloc();
:};
entete ::= PROGRAMME IDENT
{:
    pileArbres.push(new Bloc(0));
    tds.entreeBloc();
:};
declas ::= decla declas | decla;
decla ::= decla_var | decla_const | decla_fonc;
decla_var ::= type lident:identifiants POINT_VIRGULE
{:
	for (String identifiant : identifiants) {
        Entree e = new EntreeEntBool(new Ident(identifiant));  
        Symbole s = new SymboleEntBool(ligne, dernierType);
        tds.ajouter(e, s);
    }
:};
lident ::= IDENT:identifiant
{:
	ligne = lexer.getLine();
    ArrayList<String> identifiants = new ArrayList<String>();
    identifiants.add(identifiant);	
	RESULT = identifiants;
:}
| lident:identifiants VIRGULE IDENT:identifiant
{:
	identifiants.add(identifiant);
	RESULT = identifiants;
:};
decla_const ::= CONSTANTE type IDENT EGAL expr POINT_VIRGULE;
decla_fonc ::=  decla_fonc_debut param decla_fonc_fin
              | decla_fonc_debut decla_fonc_fin;
decla_fonc_debut ::= type IDENT:identifiant PARENTHESE_OUVRANTE
{:
        pileArbres.push(new Bloc(lexer.getLine()));
        ligne = lexer.getLine();
        tds.entreeBloc();
        Entree e = new EntreeFonction(new Ident(identifiant));
        Symbole s = new SymboleFonction(ligne, dernierType);
        tds.ajouter(e, s);
:};
decla_fonc_fin ::= PARENTHESE_FERMANTE decla DEBUT_FONC corps FIN_FONC {: tds.sortieBloc(); :};
type ::= type_base | tableau;
type_base ::= ENTIER {: dernierType = TypeEntier.getInstance(); :} | BOOLEEN  {: dernierType = TypeBooleen.getInstance(); :};
tableau ::= type_base CROCHET_OUVRANT dim CROCHET_FERMANT;
dim ::= expr POINT_POINT expr {: :} | dim VIRGULE expr POINT_POINT expr;
param ::= type IDENT:identifiant
{:
        Entree e = new EntreeEntBool(new Ident(identifiant));
        Symbole s = new SymboleEntBool(ligne, dernierType);
        tds.ajouter(e, s);
:}
 | param VIRGULE type IDENT;
corps ::= instrTemp;
instrTemp ::= instr instrTemp;
instrTemp ::= {: :};
instr ::= affectation | ecrire | lire | condition | retour | tant_que | pour;
lire ::= LIRE IDENT POINT_VIRGULE;
ecrire ::= ECRIRE expr POINT_VIRGULE | ECRIRE CONSTANTE_CHAINE POINT_VIRGULE;
affectation ::= acces EGAL expr POINT_VIRGULE
{:
    Expression source = (Expression) (pileArbres.pop());
    Idf dest = (Idf)(pileArbres.pop());
    pileArbres.push(new Affectation(dest, source, lexer.getLine()));
:};
retour ::= RETOURNE expr POINT_VIRGULE;
condition ::= SI expr ALORS corps SINON corps FIN_SI
{:
    ArrayList<Instruction> sinon = new ArrayList<Instruction>();
    sinon.add((Instruction)pileArbres.pop());
    ArrayList<Instruction> alors = new ArrayList<Instruction>();
    alors.add((Instruction)pileArbres.pop());
    Expression ec = (Expression)pileArbres.pop();
    pileArbres.push(new Condition(ec,alors,sinon,lexer.getLine()));
:};
tant_que ::= TANT_QUE expr FAIRE corps FIN_TANT_QUE
{:
    ArrayList<Instruction> faire = new ArrayList<Instruction>();
    faire.add((Instruction)pileArbres.pop());
    Expression ec = (Expression)pileArbres.pop();
    //pileArbres.push(new TantQue);
:};
pour ::= POUR IDENT:identifiant ALLANT_DE expr A expr FAIRE corps FIN_POUR
{:
    ArrayList<Instruction> faire = new ArrayList<Instruction>();
    faire.add((Instruction)pileArbres.pop());
    Expression ecFin = (Expression)pileArbres.pop();
    Expression ecDebut = (Expression)pileArbres.pop();
    Idf id = new Idf(identifiant, lexer.getLine());
    pileArbres.push(new Pour(id, ecDebut,ecFin,faire));
:};
expr ::= expr ope_bin:operateur expr
{:
    Expression d = (Expression)pileArbres.pop();
    Expression g = (Expression)pileArbres.pop();
    switch (operateur) {
        case "+":
            pileArbres.push(new Addition(g, d, ligne));
            break;
        case "-":
            pileArbres.push(new Soustraction(g, d, ligne));
            break;
        case "*":
            pileArbres.push(new Produit(g, d, ligne));
            break;
        case "/":
            pileArbres.push(new Division(g, d, ligne));
            break;
        case "==":
            pileArbres.push(new Egal(g, d, ligne));
            break;
        case "<>":
            pileArbres.push(new Different(g, d, ligne));
            break;
        case "<=":
            pileArbres.push(new InfEgal(g, d, ligne));
            break;
        case ">=":
            pileArbres.push(new SupEgal(g, d, ligne));
            break;
        case "<":
            pileArbres.push(new Inferieur(g, d, ligne));
            break;
        case ">":
            pileArbres.push(new Superieur(g, d, ligne));
            break;
    }
:}
| ope_un expr | PARENTHESE_OUVRANTE expr PARENTHESE_FERMANTE | operande;
acces ::= IDENT:identifiant
{:
    pileArbres.push(new Idf(identifiant, ligne));
:}
 | IDENT indexTemp;
indexTemp ::= index indexTemp;
index ::= CROCHET_OUVRANT expr CROCHET_FERMANT;
operande ::= acces | appel_fct | CONSTANTE_ENT | VRAI | FAUX;
ope_bin ::= PLUS {: RESULT = "+"; :}
            | MOINS {: RESULT = "-"; :}
            | FOIS {: RESULT = "*"; :}
            | DIVISER {: RESULT = "/"; :}
            | EGAL_EGAL {: RESULT = "=="; :}
            | DIFFERENT {: RESULT = "<>"; :}
            | OU {: RESULT = "ou"; :}
            | ET {: RESULT = "et"; :}
            | PLUS_PETIT {: RESULT = "<"; :}
            | PLUS_PETIT_OU_EGAL {: RESULT = "<="; :}
            | PLUS_GRAND {: RESULT = ">"; :}
            | PLUS_GRAND_OU_EGAL {: RESULT = ">="; :};
ope_un ::= TILDE | NON;
appel_fct ::= IDENT PARENTHESE_OUVRANTE PARENTHESE_FERMANTE | IDENT PARENTHESE_OUVRANTE par_eff PARENTHESE_FERMANTE;
par_eff ::= expr | par_eff VIRGULE expr;
