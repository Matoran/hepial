/*
    Cyril ISELI, Marco RODRIGUES
    
    Janvier 2017

    GRAMMAIRE HEPIAL
*/

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import TDS.*;



parser code {:
    private Lexer lexer = (Lexer)getScanner();
    private TDS tds = TDS.getInstance();
    private Type dernierType;
    private int ligne = 0;
:}

//--------------------Terminaux----------------------------------------
//mot clef
terminal DEBUT_PRG, FIN_PRG, PROGRAMME, DEBUT_FONC, FIN_FONC, RETOURNE;
//type
terminal TypeEntier ENTIER;
terminal TypeBoolean BOOLEEN;
terminal int CONSTANTE_ENT;
terminal String IDENT, CONSTANTE_CHAINE;
terminal CONSTANTE, VRAI, FAUX;
//operateur
terminal PARENTHESE_OUVRANTE, PARENTHESE_FERMANTE, VIRGULE, EGAL, POINT_VIRGULE, CROCHET_OUVRANT, CROCHET_FERMANT, POINT_POINT, PLUS, MOINS, FOIS, DIVISER, EGAL_EGAL, DIFFERENT, PLUS_PETIT, PLUS_PETIT_OU_EGAL, PLUS_GRAND, PLUS_GRAND_OU_EGAL, ET, OU, TILDE, NON;
//IO
terminal LIRE, ECRIRE;
//condition
terminal SI, ALORS, SINON, FIN_SI;
//boucle
terminal TANT_QUE, FAIRE, FIN_TANT_QUE, POUR, ALLANT_DE, A, FIN_POUR;

//--------------------Non Terminaux------------------------------------
non terminal axiome, programme, entete, decla, decla_var, decla_const, decla_fonc, decla_fonc_debut, decla_fonc_fin, type, type_base, tableau, dim, param, corps, instr, lire, ecrire, affectation, retour, condition, tant_que, pour, expr, acces, index, operande, ope_bin, ope_un, appel_fct, par_eff, instrTemp, indexTemp, declas;
non terminal ArrayList<String> lident;

//--------------------Precedences--------------------------------------
precedence left PLUS, MOINS, FOIS, DIVISER, EGAL_EGAL, DIFFERENT, PLUS_PETIT, PLUS_PETIT_OU_EGAL, PLUS_GRAND, PLUS_GRAND_OU_EGAL, ET, OU, POINT_POINT;
precedence right TILDE, NON;


//-------------------Regles de grammaire--------------------------------
axiome ::= programme {: System.out.println(tds); :};
programme ::= entete declas DEBUT_PRG corps FIN_PRG
{:
    tds.sortieBloc();
:};
entete ::= PROGRAMME IDENT
{:
    tds.entreeBloc();
:};
declas ::= decla declas | decla;
decla ::= decla_var | decla_const | decla_fonc;
decla_var ::= type lident:identifiants POINT_VIRGULE
{:
	for (String identifiant : identifiants) {
        Entree e = new EntreeEntBool(new Ident(identifiant));  
        Symbole s = new SymboleEntBool(ligne, dernierType);
        tds.ajouter(e, s);
    }
:};
lident ::= IDENT:identifiant
{:
	ligne = lexer.getLine();
    ArrayList<String> identifiants = new ArrayList<String>();
    identifiants.add(identifiant);	
	RESULT = identifiants;
:}
| lident:identifiants VIRGULE IDENT:identifiant
{:
	identifiants.add(identifiant);
	RESULT = identifiants;
:};
decla_const ::= CONSTANTE type IDENT EGAL expr POINT_VIRGULE;
decla_fonc ::=  decla_fonc_debut param decla_fonc_fin
              | decla_fonc_debut decla_fonc_fin;
decla_fonc_debut ::= type IDENT:identifiant PARENTHESE_OUVRANTE
{:
        ligne = lexer.getLine();
        tds.entreeBloc();
        Entree e = new EntreeFonction(new Ident(identifiant));
        Symbole s = new SymboleFonction(ligne, dernierType);
        tds.ajouter(e, s);
:};
decla_fonc_fin ::= PARENTHESE_FERMANTE decla DEBUT_FONC corps FIN_FONC {: tds.sortieBloc(); :};
type ::= type_base | tableau;
type_base ::= ENTIER {: dernierType = TypeEntier.getInstance(); :} | BOOLEEN  {: dernierType = TypeBooleen.getInstance(); :};
tableau ::= type_base CROCHET_OUVRANT dim CROCHET_FERMANT;
dim ::= expr POINT_POINT expr {: :} | dim VIRGULE expr POINT_POINT expr;
param ::= type IDENT:identifiant
{:
        Entree e = new EntreeEntBool(new Ident(identifiant));
        Symbole s = new SymboleEntBool(ligne, dernierType);
        tds.ajouter(e, s);
:}
 | param VIRGULE type IDENT;
corps ::= instrTemp;
instrTemp ::= instr instrTemp;
instrTemp ::= {: :};
instr ::= affectation | ecrire | lire | condition | retour | tant_que | pour;
lire ::= LIRE IDENT POINT_VIRGULE;
ecrire ::= ECRIRE expr POINT_VIRGULE | ECRIRE CONSTANTE_CHAINE POINT_VIRGULE;
affectation ::= acces EGAL expr POINT_VIRGULE;
retour ::= RETOURNE expr POINT_VIRGULE;
condition ::= SI expr ALORS corps SINON corps FIN_SI;
tant_que ::= TANT_QUE expr FAIRE corps FIN_TANT_QUE;
pour ::= POUR IDENT ALLANT_DE expr A expr FAIRE corps FIN_POUR;
expr ::= expr ope_bin expr | ope_un expr | PARENTHESE_OUVRANTE expr PARENTHESE_FERMANTE | operande;
acces ::= IDENT | IDENT indexTemp;
indexTemp ::= index indexTemp;
index ::= CROCHET_OUVRANT expr CROCHET_FERMANT;
operande ::= acces | appel_fct | CONSTANTE_ENT | VRAI | FAUX;
ope_bin ::= PLUS | MOINS | FOIS | DIVISER | EGAL_EGAL | DIFFERENT | OU | ET | PLUS_PETIT | PLUS_PETIT_OU_EGAL | PLUS_GRAND | PLUS_GRAND_OU_EGAL;
ope_un ::= TILDE | NON;
appel_fct ::= IDENT PARENTHESE_OUVRANTE PARENTHESE_FERMANTE | IDENT PARENTHESE_OUVRANTE par_eff PARENTHESE_FERMANTE;
par_eff ::= expr | par_eff VIRGULE expr;
